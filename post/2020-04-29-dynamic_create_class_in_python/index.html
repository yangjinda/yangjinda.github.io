<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary"><meta name=twitter:title content="python中动态创建类"><meta name=twitter:description content><meta name=twitter:site content="@"><meta property="og:title" content="python中动态创建类 &#183; Jayden's Blog"><meta property="og:site_name" content="Jayden's Blog"><meta property="og:url" content="https://yangjinda.github.io/post/2020-04-29-dynamic_create_class_in_python/"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/yangjinda/image_host/myblog_title_backgroud.jpg"><meta property="og:description" content><meta property="og:type" content="article"><meta property="article:published_time" content="2020-04-29T00:00:00Z"><meta property="article:tag" content="python"><title>python中动态创建类 &#183; Jayden's Blog</title><meta name=description content="常见类的创建方法 # classic style class A: pass # new style class A(object): pass 但总有些情况我们不想或是不能使用这种定义方式。希望可以用函数的方式动态的创建一个类或是继承一个类，来实现我们的需求。 python作为一种动态语言是这次这种方式的"><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://yangjinda.github.io/images/favicon.ico><link rel=apple-touch-icon href=https://yangjinda.github.io/images/apple-touch-icon.png><link rel=stylesheet type=text/css href=https://yangjinda.github.io/css/screen.css><link rel=stylesheet type=text/css href=https://yangjinda.github.io/css/nav.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link href=https://yangjinda.github.io/index.xml rel=alternate type=application/rss+xml title="Jayden's Blog"><meta name=generator content="Hugo 0.74.3"><link rel=canonical href=https://yangjinda.github.io/post/2020-04-29-dynamic_create_class_in_python/><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","publisher":{"@type":"Organization","name":null},"author":{"@type":"Person","name":null,"url":"https://yangjinda.github.io/","sameAs":[]},"headline":"python中动态创建类","name":"python中动态创建类","wordCount":1105,"timeRequired":"PT3M","inLanguage":{"@type":"Language","alternateName":"zh"},"url":"https://yangjinda.github.io/post/2020-04-29-dynamic_create_class_in_python/","datePublished":"2020-04-29T00:00Z","dateModified":"2020-04-29T00:00Z","keywords":"python","description":"","mainEntityOfPage":{"@type":"WebPage","@id":"https://yangjinda.github.io/post/2020-04-29-dynamic_create_class_in_python/"}}</script></head><body class=nav-closed><div class=nav><h3 class=nav-title>Menu</h3><a href=# class=nav-close><span class=hidden>Close</span></a><ul><li class=nav-opened role=presentation><a href=https://yangjinda.github.io/post>Posts</a></li><li class=nav-opened role=presentation><a href=https://yangjinda.github.io/categories>Categories</a></li><li class=nav-opened role=presentation><a href=https://yangjinda.github.io/tags>Tags</a></li><li class=nav-opened role=presentation><a href=https://yangjinda.github.io/about>About</a></li></ul><a class="subscribe-button icon-feed" href=https://yangjinda.github.io/index.xml>Subscribe</a></div><span class=nav-cover></span><div class=site-wrapper><header class="main-header post-head no-cover"><nav class="main-nav clearfix"><a class=menu-button href=#><span class=burger>&#9776;</span><span class=word>Menu</span></a></nav></header><main class=content role=main><article class="post post"><header class=post-header><h1 class=post-title>python中动态创建类</h1><small></small><section class=post-meta><time class=post-date datetime=2020-04-29T00:00:00Z>Apr 29, 2020</time>
<span class="post-tag small"><a href=https://yangjinda.github.io/tags/python/>#python</a></span></section></header><section class=post-content><p></p><h4 id=常见类的创建方法>常见类的创建方法</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># classic style</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
    <span style=color:#66d9ef>pass</span>

<span style=color:#75715e># new style</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>(object):
    <span style=color:#66d9ef>pass</span>
</code></pre></div><p>但总有些情况我们不想或是不能使用这种定义方式。希望可以用函数的方式动态的创建一个类或是继承一个类，来实现我们的需求。
python作为一种动态语言是这次这种方式的，当然这种hack方式并不推荐在较大工程中使用，会影响代码可读性和pylint等代码检查工具。
但是如果是一些小的工具函数中，使用这个方式可以很好的衔接函数式编码风格和面向对象编码风格，并且会使代码更精炼内聚性更高。
同时通过这种方式，可以更深入的研究的python的底层机制。</p><h4 id=动态创建类的方法>动态创建类的方法</h4><p>其实python中提供了一个函数可以动态创建一个类，就是type函数，此函数比较常规的使用方式是type(a)这种，用来查a的类型。但其实此函数通过传不同的参数也可以实现类的定义。
type函数实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>type</span>(object):
    <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>    type(object) -&gt; the object&#39;s type
</span><span style=color:#e6db74>    type(name, bases, dict) -&gt; a new type
</span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
    <span style=color:#66d9ef>def</span> __init__(cls, what, bases<span style=color:#f92672>=</span>None, dict<span style=color:#f92672>=</span>None): <span style=color:#75715e># known special case of type.__init__</span>
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        type(object) -&gt; the object&#39;s type
</span><span style=color:#e6db74>        type(name, bases, dict) -&gt; a new type
</span><span style=color:#e6db74>        # (copied from class doc)
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>pass</span>
</code></pre></div><p>python中动态创建一个类如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>(object):
    <span style=color:#66d9ef>pass</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
    <span style=color:#66d9ef>pass</span>
AB <span style=color:#f92672>=</span> type(<span style=color:#e6db74>&#39;AB&#39;</span>, (A, B), {<span style=color:#e6db74>&#39;ab&#39;</span>: None})
</code></pre></div><p>type中的参数为：</p><ol><li>第一个参数为要创建的类名</li><li>第二个参数为继承需要继承的父类，也可以为空</li><li>第三个参数类中的成员定义，也可以为空字典</li></ol><p>type的返回值为一个type，也就是一个class（python中new style的class都是继承的type这个类型）。此种方式与我们常用的声明式定义效果相同，其实python解释器中，也是通过调用type函数来定义一个类。
注意:</p><ul><li>此处有个一个需要注意的点，继承多个父类的时候，只会执行tuple中第一个父类的__init__函数，这个和python的new-style class的继承初始有关，可以参看新式类的初始化相关。</li><li>还有个点是type函数不支持keyword arguments形式的函数赋值，原因是type为C-level API，所以不支持。</li></ul><h4 id=特殊情况>特殊情况</h4><p>上述方式适用于绝大多数情况，但有一种情况特殊&ndash;继承的父类都是老式类（classic style），不能使用上述方法。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
    <span style=color:#66d9ef>pass</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
    <span style=color:#66d9ef>pass</span>
AB <span style=color:#f92672>=</span> type(<span style=color:#e6db74>&#39;AB&#39;</span>, (A, B), {<span style=color:#e6db74>&#39;ab&#39;</span>: None})
<span style=color:#f92672>---------------------------------------------------------------------------</span>
<span style=color:#a6e22e>TypeError</span>                                 Traceback (most recent call last)
<span style=color:#f92672>&lt;</span>ipython<span style=color:#f92672>-</span>input<span style=color:#f92672>-</span><span style=color:#ae81ff>14</span><span style=color:#f92672>-</span><span style=color:#ae81ff>42287432155</span>c<span style=color:#f92672>&gt;</span> <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>()
      <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
      <span style=color:#ae81ff>4</span>     <span style=color:#66d9ef>pass</span>
<span style=color:#f92672>----&gt;</span> <span style=color:#ae81ff>5</span> AB <span style=color:#f92672>=</span> type(<span style=color:#e6db74>&#39;AB&#39;</span>, (A, B), {<span style=color:#e6db74>&#39;ab&#39;</span>: None})

<span style=color:#a6e22e>TypeError</span>: a new<span style=color:#f92672>-</span>style <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>can</span><span style=color:#e6db74>&#39;t have only classic bases</span>
</code></pre></div><p>错误原因是type会生成一个新式类，父类中必须有一个是新式类，否则会报TypeError错误。解决办法是通过types.ClassType来生成一个老式类（classic style）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> types
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
    <span style=color:#66d9ef>pass</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
    <span style=color:#66d9ef>pass</span>
AB <span style=color:#f92672>=</span> types<span style=color:#f92672>.</span>ClassType(<span style=color:#e6db74>&#39;AB&#39;</span>, (A, B), {<span style=color:#e6db74>&#39;ab&#39;</span>: None})
</code></pre></div><p>看下types.ClassType的实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 通过type取一个老式类的类型，来生成新的类。</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_C</span>:
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_m</span>(self): <span style=color:#66d9ef>pass</span>
ClassType <span style=color:#f92672>=</span> type(_C)
</code></pre></div><p>从下面可以看出新式类和老式类的不同。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>(object):
    <span style=color:#66d9ef>pass</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
    <span style=color:#66d9ef>pass</span>
type(A) <span style=color:#f92672>--&gt;</span> type
type(B) <span style=color:#f92672>--&gt;</span> classobj
</code></pre></div><h4 id=总结>总结：</h4><p>可以通过基础类型&ndash;type和classobj来生成新的类。</p></section><footer class=post-footer><section class=author><h4><a href=https://yangjinda.github.io>Jarden</a></h4><p>Read <a href=https://yangjinda.github.io>more posts</a> by this author.</p><div class=author-meta><span class="author-location icon-location">Beijing, China</span>
<span class="author-link icon-link"><a href=https://yangjinda.github.io/>https://yangjinda.github.io/</a></span></div></section><section class=share><h4>Share this post</h4><a class=icon-twitter style=font-size:1.4em href="https://twitter.com/share?text=python%e4%b8%ad%e5%8a%a8%e6%80%81%e5%88%9b%e5%bb%ba%e7%b1%bb&nbsp;-&nbsp;Jayden%27s%20Blog&url=https%3a%2f%2fyangjinda.github.io%2fpost%2f2020-04-29-dynamic_create_class_in_python%2f" onclick="window.open(this.href,'twitter-share','width=550,height=235');return false;"><span class=hidden>Twitter</span></a>
<a class=icon-facebook style=font-size:1.4em href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fyangjinda.github.io%2fpost%2f2020-04-29-dynamic_create_class_in_python%2f" onclick="window.open(this.href,'facebook-share','width=580,height=296');return false;"><span class=hidden>Facebook</span></a>
<a class=icon-pinterest style=font-size:1.4em href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fyangjinda.github.io%2fpost%2f2020-04-29-dynamic_create_class_in_python%2f&description=python%e4%b8%ad%e5%8a%a8%e6%80%81%e5%88%9b%e5%bb%ba%e7%b1%bb" onclick="window.open(this.href,'pinterest-share','width=580,height=296');return false;"><span class=hidden>Pinterest</span></a>
<a class=icon-google-plus style=font-size:1.4em href="https://plus.google.com/share?url=https%3a%2f%2fyangjinda.github.io%2fpost%2f2020-04-29-dynamic_create_class_in_python%2f" onclick="window.open(this.href,'google-plus-share','width=490,height=530');return false;"><span class=hidden>Google+</span></a></section></footer></article></main><aside class=read-next><a class=read-next-story style=no-cover href=https://yangjinda.github.io/post/2020-05-01-how_to_use_jsdelivr_for_img_cdn/><section class=post><h2>使用github的免费cdn图床</h2></section></a><a class="read-next-story prev" style=no-cover href=https://yangjinda.github.io/post/2020-04-23-binary_search/><section class=post><h2>二分搜索详解</h2></section></a></aside><footer class="site-footer clearfix"><section class=copyright><a href>Jayden's Blog</a> All rights reserved - 2019</section><section class=poweredby>Proudly generated by <a class=icon-hugo href=http://gohugo.io>HUGO</a>, with <a class=icon-theme href=https://github.com/vjeantet/hugo-theme-casper>Casper</a> theme</section></footer></div><script type=text/javascript src=https://yangjinda.github.io/js/jquery.js></script><script type=text/javascript src=https://yangjinda.github.io/js/jquery.fitvids.js></script><script type=text/javascript src=https://yangjinda.github.io/js/index.js></script></body></html>